<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Algo__AState (Synduce.Algo__AState)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">Synduce</a> &#x00BB; Algo__AState</nav><h1>Module <code>Algo__AState</code></h1></header><aside><p>AState: This module contains state variables for the synthesis algorithms, as well as type definitions and printing functions for displaying solutions.</p></aside><dl><dt class="spec type" id="type-psi_def"><a href="#type-psi_def" class="anchor"></a><code><span class="keyword">type</span> psi_def</code><code> = </code><code>{</code><table class="record"><tr id="type-psi_def.psi_target" class="anchored"><td class="def field"><a href="#type-psi_def.psi_target" class="anchor"></a><code>psi_target : <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a>;</code></td><td class="doc"><p>The target recursion skeleton in the problem.</p></td></tr><tr id="type-psi_def.psi_reference" class="anchored"><td class="def field"><a href="#type-psi_def.psi_reference" class="anchor"></a><code>psi_reference : <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a>;</code></td><td class="doc"><p>The reference function in the problem.</p></td></tr><tr id="type-psi_def.psi_repr" class="anchored"><td class="def field"><a href="#type-psi_def.psi_repr" class="anchor"></a><code>psi_repr : <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a>;</code></td><td class="doc"><p>The representation function in the problem.</p></td></tr><tr id="type-psi_def.psi_tinv" class="anchored"><td class="def field"><a href="#type-psi_def.psi_tinv" class="anchor"></a><code>psi_tinv : <span><a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a> Base.option</span>;</code></td><td class="doc"><p>The requires predicate of the target recursion skeleton.</p></td></tr><tr id="type-psi_def.psi_repr_is_identity" class="anchored"><td class="def field"><a href="#type-psi_def.psi_repr_is_identity" class="anchor"></a><code>psi_repr_is_identity : Base.bool;</code></td><td class="doc"><p>A boolean that is true iff psi_repr is identity.</p></td></tr><tr id="type-psi_def.psi_lifting" class="anchored"><td class="def field"><a href="#type-psi_def.psi_lifting" class="anchor"></a><code>psi_lifting : <span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> Base.list</span>;</code></td><td class="doc"><p>The current lifting: the output type of psi_target should be !_alpha extended with the tuple of types psi_lifting.</p></td></tr></table><code>}</code></dt></dl><aside><p>psi_def is the definition of the problem: the goal is to synthesize the unknowns in target such that target = orig ∘ repr</p></aside><dl><dt class="spec value" id="val-_tau"><a href="#val-_tau" class="anchor"></a><code><span class="keyword">val</span> _tau : <span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> Base.ref</span></code></dt><dd><p>The type τ in the paper, input type of the reference function.</p></dd></dl><dl><dt class="spec value" id="val-_theta"><a href="#val-_theta" class="anchor"></a><code><span class="keyword">val</span> _theta : <span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> Base.ref</span></code></dt><dd><p>The type θ in the paper, input type of the target recursion skeleton.</p></dd></dl><dl><dt class="spec value" id="val-_alpha"><a href="#val-_alpha" class="anchor"></a><code><span class="keyword">val</span> _alpha : <span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> Base.ref</span></code></dt><dd><p>The type D in the paper: the output type of the reference and the target recursion skeleton. The first element is the pure type output type of the functions, and the second element is an optional term that represents the additional predicate on the output of the reference function. The term is assumed to define a function (fun (free variables of term) -&gt; term).</p></dd></dl><dl><dt class="spec value" id="val-_span"><a href="#val-_span" class="anchor"></a><code><span class="keyword">val</span> _span : <span>int Base.ref</span></code></dt><dd><p>Not useful for now.</p></dd></dl><dl><dt class="spec value" id="val-refinement_steps"><a href="#val-refinement_steps" class="anchor"></a><code><span class="keyword">val</span> refinement_steps : <span>int Base.ref</span></code></dt><dt class="spec value" id="val-secondary_refinement_steps"><a href="#val-secondary_refinement_steps" class="anchor"></a><code><span class="keyword">val</span> secondary_refinement_steps : <span>int Base.ref</span></code></dt><dt class="spec value" id="val-reinit"><a href="#val-reinit" class="anchor"></a><code><span class="keyword">val</span> reinit : unit <span>&#45;&gt;</span> Base.unit</code></dt></dl><dl><dt class="spec type" id="type-soln"><a href="#type-soln" class="anchor"></a><code><span class="keyword">type</span> soln</code><code> = </code><code>{</code><table class="record"><tr id="type-soln.soln_rec_scheme" class="anchored"><td class="def field"><a href="#type-soln.soln_rec_scheme" class="anchor"></a><code>soln_rec_scheme : <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a>;</code></td><td class="doc"><p>The recursion scheme this object is a solution of.</p></td></tr><tr id="type-soln.soln_implems" class="anchored"><td class="def field"><a href="#type-soln.soln_implems" class="anchor"></a><code>soln_implems : <span><span>(<a href="../Syguslib/Sygus/index.html#type-symbol">Syguslib.Sygus.symbol</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span>;</code></td><td class="doc"><p>The association list containing the implementation of each unknown. Each element of the list is a triple of unknown name, list of arguments, and body of the unknown implementation.</p></td></tr></table><code>}</code></dt><dd><p>Representation of a solution, i.e. a function (as a PMRS) together with an association list from unknown name to its implementation.</p></dd></dl><dl><dt class="spec type" id="type-equation"><a href="#type-equation" class="anchor"></a><code><span class="keyword">type</span> equation</code><code> = </code><code>{</code><table class="record"><tr id="type-equation.eterm" class="anchored"><td class="def field"><a href="#type-equation.eterm" class="anchor"></a><code>eterm : <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>;</code></td><td class="doc"><p>The term from which the equation originates.</p></td></tr><tr id="type-equation.eprecond" class="anchored"><td class="def field"><a href="#type-equation.eprecond" class="anchor"></a><code>eprecond : <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.option</span>;</code></td><td class="doc"><p>An optional precondition to the equation.</p></td></tr><tr id="type-equation.elhs" class="anchored"><td class="def field"><a href="#type-equation.elhs" class="anchor"></a><code>elhs : <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>;</code></td><td class="doc"><p>The left-hand side of the equation, containing no unknowns.</p></td></tr><tr id="type-equation.erhs" class="anchored"><td class="def field"><a href="#type-equation.erhs" class="anchor"></a><code>erhs : <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>;</code></td><td class="doc"><p>The right-hand side of the equation, possibly with unknowns.</p></td></tr><tr id="type-equation.eelim" class="anchored"><td class="def field"><a href="#type-equation.eelim" class="anchor"></a><code>eelim : <span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span>;</code></td><td class="doc"><p>The substitution used to eliminate recursion.</p></td></tr></table><code>}</code></dt><dd><p>Represents an equational constraint.</p></dd></dl><dl><dt class="spec type" id="type-spurious_cause"><a href="#type-spurious_cause" class="anchor"></a><code><span class="keyword">type</span> spurious_cause</code><code> = </code><table class="variant"><tr id="type-spurious_cause.ViolatesTargetRequires" class="anchored"><td class="def constructor"><a href="#type-spurious_cause.ViolatesTargetRequires" class="anchor"></a><code>| </code><code><span class="constructor">ViolatesTargetRequires</span></code></td></tr><tr id="type-spurious_cause.NotInReferenceImage" class="anchored"><td class="def constructor"><a href="#type-spurious_cause.NotInReferenceImage" class="anchor"></a><code>| </code><code><span class="constructor">NotInReferenceImage</span></code></td><td class="doc"><p>A counterexample can be spurious either because it wiolates the target's requires or because some values assigned to recursion elimination variables are not in the reference function's image.</p></td></tr></table></dt><dt class="spec type" id="type-ctex_stat"><a href="#type-ctex_stat" class="anchor"></a><code><span class="keyword">type</span> ctex_stat</code><code> = </code><table class="variant"><tr id="type-ctex_stat.Valid" class="anchored"><td class="def constructor"><a href="#type-ctex_stat.Valid" class="anchor"></a><code>| </code><code><span class="constructor">Valid</span></code></td></tr><tr id="type-ctex_stat.Spurious" class="anchored"><td class="def constructor"><a href="#type-ctex_stat.Spurious" class="anchor"></a><code>| </code><code><span class="constructor">Spurious</span> <span class="keyword">of</span> <a href="index.html#type-spurious_cause">spurious_cause</a></code></td></tr><tr id="type-ctex_stat.Unknown" class="anchored"><td class="def constructor"><a href="#type-ctex_stat.Unknown" class="anchor"></a><code>| </code><code><span class="constructor">Unknown</span></code></td><td class="doc"><p>A counterexample is either valid, or spurious with some reason, or unknown.</p></td></tr></table></dt><dt class="spec type" id="type-ctex"><a href="#type-ctex" class="anchor"></a><code><span class="keyword">type</span> ctex</code><code> = </code><code>{</code><table class="record"><tr id="type-ctex.ctex_eqn" class="anchored"><td class="def field"><a href="#type-ctex.ctex_eqn" class="anchor"></a><code>ctex_eqn : <a href="index.html#type-equation">equation</a>;</code></td><td class="doc"><p>The equation the counterexample relates to.</p></td></tr><tr id="type-ctex.ctex_vars" class="anchored"><td class="def field"><a href="#type-ctex.ctex_vars" class="anchor"></a><code>ctex_vars : <a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a>;</code></td><td class="doc"><p>The variables in the model.</p></td></tr><tr id="type-ctex.ctex_model" class="anchored"><td class="def field"><a href="#type-ctex.ctex_model" class="anchor"></a><code>ctex_model : <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> <a href="../Lang/Term/VarMap/index.html#type-t">Lang.Term.VarMap.t</a></span>;</code></td><td class="doc"><p>The model of the counterexample, mapping variables to terms. The terms should be constants.</p></td></tr><tr id="type-ctex.ctex_stat" class="anchored"><td class="def field"><a href="#type-ctex.ctex_stat" class="anchor"></a><code>ctex_stat : <a href="index.html#type-ctex_stat">ctex_stat</a>;</code></td><td class="doc"><p>The spuriousness status of the counterexample.</p></td></tr></table><code>}</code></dt><dd><p>A counterexample related to an equation and some info on the validity of the counterexample.</p></dd></dl><dl><dt class="spec type" id="type-equation_system"><a href="#type-equation_system" class="anchor"></a><code><span class="keyword">type</span> equation_system</code><code> = <span><a href="index.html#type-equation">equation</a> Base.list</span></code></dt></dl><dl><dt class="spec value" id="val-solved_eqn_system"><a href="#val-solved_eqn_system" class="anchor"></a><code><span class="keyword">val</span> solved_eqn_system : <span><span><a href="index.html#type-equation_system">equation_system</a> Base.option</span> Base.ref</span></code></dt><dd><p>Contains the last equation system used to solved the problem when a solution is found.</p></dd></dl><dl><dt class="spec type" id="type-term_state_detail"><a href="#type-term_state_detail" class="anchor"></a><code><span class="keyword">type</span> term_state_detail</code><code> = </code><code>{</code><table class="record"><tr id="type-term_state_detail.term" class="anchored"><td class="def field"><a href="#type-term_state_detail.term" class="anchor"></a><code>term : <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>;</code></td></tr><tr id="type-term_state_detail.lemmas" class="anchored"><td class="def field"><a href="#type-term_state_detail.lemmas" class="anchor"></a><code>lemmas : <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.list</span>;</code></td></tr><tr id="type-term_state_detail.lemma_candidate" class="anchored"><td class="def field"><a href="#type-term_state_detail.lemma_candidate" class="anchor"></a><code>lemma_candidate : <span><span>(Base.string * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.option</span>;</code></td></tr><tr id="type-term_state_detail.negative_ctexs" class="anchored"><td class="def field"><a href="#type-term_state_detail.negative_ctexs" class="anchor"></a><code>negative_ctexs : <span><a href="index.html#type-ctex">ctex</a> Base.list</span>;</code></td></tr><tr id="type-term_state_detail.positive_ctexs" class="anchored"><td class="def field"><a href="#type-term_state_detail.positive_ctexs" class="anchor"></a><code>positive_ctexs : <span><a href="index.html#type-ctex">ctex</a> Base.list</span>;</code></td></tr><tr id="type-term_state_detail.recurs_elim" class="anchored"><td class="def field"><a href="#type-term_state_detail.recurs_elim" class="anchor"></a><code>recurs_elim : <span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span>;</code></td></tr><tr id="type-term_state_detail.scalar_vars" class="anchored"><td class="def field"><a href="#type-term_state_detail.scalar_vars" class="anchor"></a><code>scalar_vars : <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span>;</code></td></tr><tr id="type-term_state_detail.current_preconds" class="anchored"><td class="def field"><a href="#type-term_state_detail.current_preconds" class="anchor"></a><code>current_preconds : <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.option</span>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-term_state"><a href="#type-term_state" class="anchor"></a><code><span class="keyword">type</span> term_state</code><code> = <span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>, <a href="index.html#type-term_state_detail">term_state_detail</a>, <a href="../Lang/Term/Terms/index.html#type-comparator_witness">Lang.Term.Terms.comparator_witness</a>)</span> Base.Map.t</span></code></dt><dt class="spec type" id="type-lifting"><a href="#type-lifting" class="anchor"></a><code><span class="keyword">type</span> lifting</code><code> = </code><code>{</code><table class="record"><tr id="type-lifting.tmap" class="anchored"><td class="def field"><a href="#type-lifting.tmap" class="anchor"></a><code>tmap : <span><span>(<span>(Base.int * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type to describe liftings. tmap is a map from terms to the expression of the lifting.</p></dd></dl><dl><dt class="spec type" id="type-refinement_loop_state"><a href="#type-refinement_loop_state" class="anchor"></a><code><span class="keyword">type</span> refinement_loop_state</code><code> = </code><code>{</code><table class="record"><tr id="type-refinement_loop_state.t_set" class="anchored"><td class="def field"><a href="#type-refinement_loop_state.t_set" class="anchor"></a><code>t_set : <a href="../Lang/Term/TermSet/index.html#type-t">Lang.Term.TermSet.t</a>;</code></td></tr><tr id="type-refinement_loop_state.u_set" class="anchored"><td class="def field"><a href="#type-refinement_loop_state.u_set" class="anchor"></a><code>u_set : <a href="../Lang/Term/TermSet/index.html#type-t">Lang.Term.TermSet.t</a>;</code></td></tr><tr id="type-refinement_loop_state.term_state" class="anchored"><td class="def field"><a href="#type-refinement_loop_state.term_state" class="anchor"></a><code>term_state : <a href="index.html#type-term_state">term_state</a>;</code></td></tr><tr id="type-refinement_loop_state.lifting" class="anchored"><td class="def field"><a href="#type-refinement_loop_state.lifting" class="anchor"></a><code>lifting : <a href="index.html#type-lifting">lifting</a>;</code></td></tr></table><code>}</code></dt><dd><p>The state of the main refinement loop. Currently, it is entirely determined by the sets T and U, accompanied with a set of lemmas that can be used during the generation of constraints.</p></dd></dl><dl><dt class="spec value" id="val-pp_equation"><a href="#val-pp_equation" class="anchor"></a><code><span class="keyword">val</span> pp_equation : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-equation">equation</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp_ctex"><a href="#val-pp_ctex" class="anchor"></a><code><span class="keyword">val</span> pp_ctex : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-ctex">ctex</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp_implems"><a href="#val-pp_implems" class="anchor"></a><code><span class="keyword">val</span> pp_implems : Base.Formatter.t <span>&#45;&gt;</span> <span><span>(<a href="../Syguslib/Sygus/index.html#type-symbol">Syguslib.Sygus.symbol</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_soln"><a href="#val-pp_soln" class="anchor"></a><code><span class="keyword">val</span> pp_soln : <span>?&#8288;use_ocaml_syntax:bool</span> <span>&#45;&gt;</span> Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-soln">soln</a> <span>&#45;&gt;</span> Base.unit</code></dt></dl></div></body></html>