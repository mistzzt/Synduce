<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Algo__Counterexamples (Synduce.Algo__Counterexamples)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">Synduce</a> &#x00BB; Algo__Counterexamples</nav><h1>Module <code>Algo__Counterexamples</code></h1></header><dl><dt class="spec value" id="val-smt_unsatisfiability_check"><a href="#val-smt_unsatisfiability_check" class="anchor"></a><code><span class="keyword">val</span> smt_unsatisfiability_check : <a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a> <span>&#45;&gt;</span> <span><a href="../Algo/AState/index.html#type-equation">Algo.AState.equation</a> Base.list</span> <span>&#45;&gt;</span> Base.unit</code></dt></dl><dl><dt class="spec type" id="type-unrealizability_ctex"><a href="#type-unrealizability_ctex" class="anchor"></a><code><span class="keyword">type</span> unrealizability_ctex</code><code> = </code><code>{</code><table class="record"><tr id="type-unrealizability_ctex.i" class="anchored"><td class="def field"><a href="#type-unrealizability_ctex.i" class="anchor"></a><code>i : Base.int;</code></td></tr><tr id="type-unrealizability_ctex.j" class="anchored"><td class="def field"><a href="#type-unrealizability_ctex.j" class="anchor"></a><code>j : Base.int;</code></td></tr><tr id="type-unrealizability_ctex.ci" class="anchored"><td class="def field"><a href="#type-unrealizability_ctex.ci" class="anchor"></a><code>ci : <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a>;</code></td></tr><tr id="type-unrealizability_ctex.cj" class="anchored"><td class="def field"><a href="#type-unrealizability_ctex.cj" class="anchor"></a><code>cj : <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a>;</code></td></tr></table><code>}</code></dt><dd><p>A counterexample to realizability is a pair of models: a pair of maps from variable ids to terms.</p></dd></dl><dl><dt class="spec value" id="val-pp_unrealizability_ctex"><a href="#val-pp_unrealizability_ctex" class="anchor"></a><code><span class="keyword">val</span> pp_unrealizability_ctex : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-unrealizability_ctex">unrealizability_ctex</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-reinterpret_model"><a href="#val-reinterpret_model" class="anchor"></a><code><span class="keyword">val</span> reinterpret_model : <span>(<span><span>(Base.string, <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Base.Map.t</span> * <span><span>(Base.string, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> Base.Map.t</span>)</span> <span>&#45;&gt;</span> <span><span>(<a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a>)</span> Base.List.t</span> <span>&#45;&gt;</span> <span><span>(<a href="../Lang__Term/Variable/index.html#type-t">Lang__Term.Variable.t</a>, <span class="type-var">'a</span>, <a href="../Lang__Term/Variable/index.html#type-comparator_witness">Lang__Term.Variable.comparator_witness</a>)</span> Base.Map.t</span> * <span><span>(<a href="../Lang__Term/Variable/index.html#type-t">Lang__Term.Variable.t</a>, <span class="type-var">'c</span>, <a href="../Lang__Term/Variable/index.html#type-comparator_witness">Lang__Term.Variable.comparator_witness</a>)</span> Base.Map.t</span></code></dt><dt class="spec value" id="val-unrealizability_ctex_of_constmap"><a href="#val-unrealizability_ctex_of_constmap" class="anchor"></a><code><span class="keyword">val</span> unrealizability_ctex_of_constmap : <span>(Base.int * Base.int)</span> <span>&#45;&gt;</span> <span>(<a href="../Algo/AState/index.html#type-equation">Algo.AState.equation</a> * <a href="../Algo/AState/index.html#type-equation">Algo.AState.equation</a>)</span> <span>&#45;&gt;</span> <span>(<span><span>(<a href="../Lang/Term/VarSet/index.html#type-elt">Lang.Term.VarSet.elt</a>, <a href="../Lang__Term/Variable/index.html#type-comparator_witness">Lang__Term.Variable.comparator_witness</a>)</span> Base.Set.t</span> * <span><span>(<a href="../Lang/Term/VarSet/index.html#type-elt">Lang.Term.VarSet.elt</a>, <a href="../Lang__Term/Variable/index.html#type-comparator_witness">Lang__Term.Variable.comparator_witness</a>)</span> Base.Set.t</span>)</span> <span>&#45;&gt;</span> <span><span>(<a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a>)</span> Base.List.t</span> <span>&#45;&gt;</span> <span><span>(Base.String.t, <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>, <span class="type-var">'a</span>)</span> Base.Map.t</span> <span>&#45;&gt;</span> <a href="index.html#type-unrealizability_ctex">unrealizability_ctex</a></code></dt><dt class="spec value" id="val-skeleton_match"><a href="#val-skeleton_match" class="anchor"></a><code><span class="keyword">val</span> skeleton_match : <span>unknowns:<a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a></span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> <span>&#45;&gt;</span> <span><span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span> Base.option</span></code></dt><dt class="spec value" id="val-components_of_unrealizability"><a href="#val-components_of_unrealizability" class="anchor"></a><code><span class="keyword">val</span> components_of_unrealizability : <span>unknowns:<a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a></span> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-equation">Algo.AState.equation</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-equation">Algo.AState.equation</a> <span>&#45;&gt;</span> <span><span>(<span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span> * <span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span>)</span> Base.option</span></code></dt><dt class="spec value" id="val-check_unrealizable"><a href="#val-check_unrealizable" class="anchor"></a><code><span class="keyword">val</span> check_unrealizable : <a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-equation_system">Algo.AState.equation_system</a> <span>&#45;&gt;</span> <span><a href="index.html#type-unrealizability_ctex">unrealizability_ctex</a> Base.list</span></code></dt><dd><p>Check if system of equations defines a functionally realizable synthesis problem. If any equation defines an unsolvable problem, an unrealizability_ctex is added to the list of counterexamples to be returned. If the returned list is empty, the problem may be solvable/realizable. If the returned list is not empty, the problem is not solvable / unrealizable.</p></dd></dl><dl><dt class="spec value" id="val-check_image_sat"><a href="#val-check_image_sat" class="anchor"></a><code><span class="keyword">val</span> check_image_sat : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Lang/SmtInterface/AsyncSmt/index.html#type-response">Lang.SmtInterface.AsyncSmt.response</a> * <span>Base.int Lwt.u</span></code></dt><dt class="spec value" id="val-check_image_unsat"><a href="#val-check_image_unsat" class="anchor"></a><code><span class="keyword">val</span> check_image_unsat : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Lang/SmtInterface/AsyncSmt/index.html#type-response">Lang.SmtInterface.AsyncSmt.response</a> * <span>Base.int Lwt.u</span></code></dt><dt class="spec value" id="val-check_ctex_in_image"><a href="#val-check_ctex_in_image" class="anchor"></a><code><span class="keyword">val</span> check_ctex_in_image : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a></code></dt><dd><p><code>check_ctex_in_image ~p ctex</code> checks whether the recursion elimination's variables values in the model of <code>ctex</code> are in the image of (p.psi_reference o p.psi_repr).</p></dd></dl><dl><dt class="spec value" id="val-find_original_var_and_proj"><a href="#val-find_original_var_and_proj" class="anchor"></a><code><span class="keyword">val</span> find_original_var_and_proj : <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * int)</span> Base.Option.t</span></code></dt><dt class="spec value" id="val-mk_model_sat_asserts"><a href="#val-mk_model_sat_asserts" class="anchor"></a><code><span class="keyword">val</span> mk_model_sat_asserts : <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> <span>&#45;&gt;</span> <span>(<a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Option.t</span>)</span> <span>&#45;&gt;</span> <span><a href="../Smtlib/SmtLib/index.html#type-smtTerm">Smtlib.SmtLib.smtTerm</a> Base.List.t</span></code></dt><dt class="spec value" id="val-check_tinv_unsat"><a href="#val-check_tinv_unsat" class="anchor"></a><code><span class="keyword">val</span> check_tinv_unsat : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Lang/SmtInterface/AsyncSmt/index.html#type-response">Lang.SmtInterface.AsyncSmt.response</a> * <span>Base.int Lwt.u</span></code></dt><dd><p><code>check_tinv_unsat ~p tinv c</code> checks whether the counterexample <code>c</code> satisfies the predicate <code>tinv</code> in the synthesis problem <code>p</code>. The function returns a promise of a solver response and the resolver associated to that promise (the promise is cancellable). If the solver response is unsat, then there is a proof that the counterexample <code>c</code> does not satisfy the predicate <code>tinv</code>. In general, if the reponse is not unsat, the solver either stalls or returns unknown.</p></dd></dl><dl><dt class="spec value" id="val-check_tinv_sat"><a href="#val-check_tinv_sat" class="anchor"></a><code><span class="keyword">val</span> check_tinv_sat : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Lang/SmtInterface/AsyncSmt/index.html#type-response">Lang.SmtInterface.AsyncSmt.response</a> * <span>Base.int Lwt.u</span></code></dt><dd><p><code>check_tinv_sat ~p tinv ctex</code> checks whether the counterexample <code>ctex</code> satisfies the invariant <code>tinv</code> (a PMRS). The function returns a pair of a promise of a solver response and a resolver for that promise. The promise is cancellable.</p></dd></dl><dl><dt class="spec value" id="val-satisfies_tinv"><a href="#val-satisfies_tinv" class="anchor"></a><code><span class="keyword">val</span> satisfies_tinv : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <a href="../Lang/PMRS/index.html#type-t">Lang.PMRS.t</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> <span>&#45;&gt;</span> <a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a></code></dt><dt class="spec value" id="val-classify_ctexs"><a href="#val-classify_ctexs" class="anchor"></a><code><span class="keyword">val</span> classify_ctexs : <span>p:<a href="../Algo/AState/index.html#type-psi_def">Algo.AState.psi_def</a></span> <span>&#45;&gt;</span> <span><a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> Base.list</span> <span>&#45;&gt;</span> <span><a href="../Algo/AState/index.html#type-ctex">Algo.AState.ctex</a> Base.list</span></code></dt><dd><p>Classify counterexamples into positive or negative counterexamples with respect to the Tinv predicate in the problem.</p></dd></dl></div></body></html>