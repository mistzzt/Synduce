<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>SmtInterface (Synduce.Lang.SmtInterface)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">Synduce</a> &#x00BB; <a href="../index.html">Lang</a> &#x00BB; SmtInterface</nav><h1>Module <code>Lang.SmtInterface</code></h1></header><dl><dt class="spec value" id="val-rtype_of_smtSort"><a href="#val-rtype_of_smtSort" class="anchor"></a><code><span class="keyword">val</span> rtype_of_smtSort : <a href="../../Smtlib/SmtLib/index.html#type-smtSort">Smtlib.SmtLib.smtSort</a> <span>&#45;&gt;</span> <span><a href="../RType/index.html#type-t">RType.t</a> option</span></code></dt><dd><p>`rtype_of_smtSort smt_sort` return `Some t` if `t` is a type representing the smt sort `smt_sort`, and `None` if no such type exists.</p></dd></dl><dl><dt class="spec value" id="val-sort_of_rtype"><a href="#val-sort_of_rtype" class="anchor"></a><code><span class="keyword">val</span> sort_of_rtype : <a href="../RType/index.html#type-t">RType.t</a> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-smtSort">Smtlib.SmtLib.smtSort</a></code></dt><dt class="spec value" id="val-smt_of_term"><a href="#val-smt_of_term" class="anchor"></a><code><span class="keyword">val</span> smt_of_term : <a href="../Term/index.html#type-term">Term.term</a> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-smtTerm">Smtlib.SmtLib.smtTerm</a></code></dt><dd><p>`smt_of_term t` generates a smt-term from the term t. If t is not a valid term, raises errors. TODO: return a Result.t instead of failing.</p></dd></dl><dl><dt class="spec value" id="val-sorted_vars_of_vars"><a href="#val-sorted_vars_of_vars" class="anchor"></a><code><span class="keyword">val</span> sorted_vars_of_vars : <a href="../Term/VarSet/index.html#type-t">Term.VarSet.t</a> <span>&#45;&gt;</span> <span><a href="../../Smtlib/SmtLib/index.html#type-smtSortedVar">Smtlib.SmtLib.smtSortedVar</a> list</span></code></dt><dd><p>Convert a set of variables into a list of smt sorted vars.</p></dd></dl><dl><dt class="spec value" id="val-smt_of_pmrs"><a href="#val-smt_of_pmrs" class="anchor"></a><code><span class="keyword">val</span> smt_of_pmrs : <a href="../PMRS/index.html#type-t">PMRS.t</a> <span>&#45;&gt;</span> <span><a href="../../Smtlib/SmtLib/index.html#type-command">Smtlib.SmtLib.command</a> list</span></code></dt><dd><p>Convert a PMRS into a set of commands. Once the commands have been passed to the solver, the PMRS can be used as a function in the solver.</p></dd></dl><dl><dt class="spec value" id="val-mk_def_fun_command"><a href="#val-mk_def_fun_command" class="anchor"></a><code><span class="keyword">val</span> mk_def_fun_command : string <span>&#45;&gt;</span> <span><span>(string * <a href="../RType/index.html#type-t">RType.t</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../RType/index.html#type-t">RType.t</a> <span>&#45;&gt;</span> <a href="../Term/index.html#type-term">Term.term</a> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-command">Smtlib.SmtLib.command</a></code></dt><dt class="spec value" id="val-mk_assert"><a href="#val-mk_assert" class="anchor"></a><code><span class="keyword">val</span> mk_assert : <a href="../../Smtlib/SmtLib/index.html#type-smtTerm">Smtlib.SmtLib.smtTerm</a> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-command">Smtlib.SmtLib.command</a></code></dt><dt class="spec value" id="val-term_of_smt"><a href="#val-term_of_smt" class="anchor"></a><code><span class="keyword">val</span> term_of_smt : <span><span>(string, <a href="../Term/index.html#type-variable">Term.variable</a>, Base.String.comparator_witness)</span> Base.Map.t</span> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-smtTerm">Smtlib.SmtLib.smtTerm</a> <span>&#45;&gt;</span> <a href="../Term/index.html#type-term">Term.term</a></code></dt><dd><p>Convert a term to a smt-term in an environment (a map from string to variables).</p></dd></dl><dl><dt class="spec type" id="type-term_model"><a href="#type-term_model" class="anchor"></a><code><span class="keyword">type</span> term_model</code><code> = <span><span>(string, <a href="../Term/index.html#type-term">Term.term</a>, Base.String.comparator_witness)</span> Base.Map.t</span></code></dt><dd><p>A term model: a map from string (variable names) to terms. In most cases these terms will be constants.</p></dd></dl><dl><dt class="spec value" id="val-model_to_constmap"><a href="#val-model_to_constmap" class="anchor"></a><code><span class="keyword">val</span> model_to_constmap : <a href="../../Smtlib/SmtLib/index.html#type-solver_response">Smtlib.SmtLib.solver_response</a> <span>&#45;&gt;</span> <a href="index.html#type-term_model">term_model</a></code></dt><dd><p>Translate a solver response (a Smtlib.Solvers.solver_response) to a term-model. Returns an empty map if the response is not a SExps (a list of s-expressions) that define a model obtained through (get-model).</p></dd></dl><dl><dt class="spec value" id="val-model_to_subst"><a href="#val-model_to_subst" class="anchor"></a><code><span class="keyword">val</span> model_to_subst : <a href="../Term/VarSet/index.html#type-t">Term.VarSet.t</a> <span>&#45;&gt;</span> <a href="../../Smtlib/SmtLib/index.html#type-solver_response">Smtlib.SmtLib.solver_response</a> <span>&#45;&gt;</span> <span><span>(<a href="../Term/index.html#type-term">Term.term</a> * <a href="../Term/index.html#type-term">Term.term</a>)</span> list</span></code></dt><dd><p>Translate a solver response (a Smtlib.Solvers.solver_response) to a term substitution list. Returns an empty list if the response is not a SExps (a list of s-expressions) that defines a model obtained through (get-model).</p></dd></dl><dl><dt class="spec value" id="val-request_different_models"><a href="#val-request_different_models" class="anchor"></a><code><span class="keyword">val</span> request_different_models : <a href="index.html#type-term_model">term_model</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../../Smtlib/Solvers/index.html#type-online_solver">Smtlib.Solvers.online_solver</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term_model">term_model</a> list</span></code></dt><dd><p><code>request_different_models m i s</code> uses solver <code>s</code> to find <code>i</code> models different from <code>m</code> that satisfy the current stack of assertions.</p></dd></dl><dl><dt class="spec value" id="val-decls_of_vars"><a href="#val-decls_of_vars" class="anchor"></a><code><span class="keyword">val</span> decls_of_vars : <a href="../Term/VarSet/index.html#type-t">Term.VarSet.t</a> <span>&#45;&gt;</span> <span><a href="../../Smtlib/SmtLib/index.html#type-command">Smtlib.SmtLib.command</a> list</span></code></dt><dd><p>Generate a list of commands from a set of variables. The list of commands may then be passsed to a Smtlib.Solvers.online_solver instance through the Smtlib.Solvers.declare_all command.</p></dd></dl></div></body></html>