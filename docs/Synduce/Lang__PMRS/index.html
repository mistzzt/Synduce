<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lang__PMRS (Synduce.Lang__PMRS)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">Synduce</a> &#x00BB; Lang__PMRS</nav><h1>Module <code>Lang__PMRS</code></h1></header><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> pattern</code><code> = Base.string * <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.list</span></code></dt><dd><p>A pattern in a PMRS rewrite rule is limited to matching terms of the form &quot;Constructor_name(arguments)&quot; where each argument is a term, and the Constructor_name is the name of a valid datatype constructor.</p></dd></dl><dl><dt class="spec type" id="type-rewrite_rule"><a href="#type-rewrite_rule" class="anchor"></a><code><span class="keyword">type</span> rewrite_rule</code><code> = <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span> * <span><a href="index.html#type-pattern">pattern</a> Base.option</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a></code></dt><dd><p>A PMRS rewrite rule <code>(v, args, pattern, rhs)</code> is the rewrite rule v(args,pattern) -&gt; rhs. <code>v</code> which is a non-terminal (a recursive function in the OCaml code), <code>args</code> is a possibly empty list of arguments, <code>pattern</code> is an optional pattern, <code>rhs</code> is the production of the rule.</p></dd></dl><dl><dt class="spec type" id="type-top_function"><a href="#type-top_function" class="anchor"></a><code><span class="keyword">type</span> top_function</code><code> = <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a></code></dt><dd><p>A toplevel function is a triple of a variable (the variable representing the function itself), a list of variables (the arguments of the function) and a term (the body of the function).</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.pvar" class="anchored"><td class="def field"><a href="#type-t.pvar" class="anchor"></a><code>pvar : <a href="../Lang/Term/Variable/index.html#type-t">Lang.Term.Variable.t</a>;</code></td><td class="doc"><p>The main function symbol, storing general information about the PMRS. The specification associated to the PMRS may be found using: <code>get_spec pvar</code> The type of the PMRS (the main function of the group of mutually recursive functions) is stored as the type of pvar.</p></td></tr><tr id="type-t.pinput_typ" class="anchored"><td class="def field"><a href="#type-t.pinput_typ" class="anchor"></a><code>pinput_typ : <span><a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> Base.list</span>;</code></td><td class="doc"><p>The input type(s). For now, it should be a singleton list. The input type is only the type of the recursively-typed argument of the PMRS, not the parameters.</p></td></tr><tr id="type-t.poutput_typ" class="anchored"><td class="def field"><a href="#type-t.poutput_typ" class="anchor"></a><code>poutput_typ : <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>;</code></td><td class="doc"><p>Output type and optional invariant on output of function.</p></td></tr><tr id="type-t.pargs" class="anchored"><td class="def field"><a href="#type-t.pargs" class="anchor"></a><code>pargs : <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.list</span>;</code></td><td class="doc"><p>Parameter arguments.</p></td></tr><tr id="type-t.psyntobjs" class="anchored"><td class="def field"><a href="#type-t.psyntobjs" class="anchor"></a><code>psyntobjs : <a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a>;</code></td><td class="doc"><p>The unknowns to synthesize.</p></td></tr><tr id="type-t.prules" class="anchored"><td class="def field"><a href="#type-t.prules" class="anchor"></a><code>prules : <span><a href="index.html#type-rewrite_rule">rewrite_rule</a> <a href="../Utils/IntMap/index.html#type-t">Utils.IntMap.t</a></span>;</code></td><td class="doc"><p>The rules of the PMRS.</p></td></tr><tr id="type-t.pnon_terminals" class="anchored"><td class="def field"><a href="#type-t.pnon_terminals" class="anchor"></a><code>pnon_terminals : <a href="../Lang/Term/VarSet/index.html#type-t">Lang.Term.VarSet.t</a>;</code></td><td class="doc"><p>Non-terminals of the PMRS.</p></td></tr><tr id="type-t.pmain_symb" class="anchored"><td class="def field"><a href="#type-t.pmain_symb" class="anchor"></a><code>pmain_symb : <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a>;</code></td><td class="doc"><p>The main symbol of the PMRS.</p></td></tr><tr id="type-t.porder" class="anchored"><td class="def field"><a href="#type-t.porder" class="anchor"></a><code>porder : Base.int;</code></td><td class="doc"><p>The order of the PMRS (mostly useless for now).</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-xresult"><a href="#type-xresult" class="anchor"></a><code><span class="keyword">type</span> <span>'a xresult</span></code><code> = <span><span>(<span class="type-var">'a</span>, <span><span>(Base.string * Base.Sexp.t)</span> Base.list</span>)</span> Base.Result.t</span></code></dt><dd><p>A result type with error messages in the form of title x s-expression.</p></dd></dl><dl><dt class="spec type" id="type-sresult"><a href="#type-sresult" class="anchor"></a><code><span class="keyword">type</span> <span>'a sresult</span></code><code> = <span><span>(<span class="type-var">'a</span>, <span><span>(Base.string * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span>)</span> Base.Result.t</span></code></dt><dd><p>A result type with error messages in the form of title x term.</p></dd></dl><dl><dt class="spec type" id="type-variables"><a href="#type-variables" class="anchor"></a><code><span class="keyword">type</span> variables</code><code> = <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.Map.M(Base.String).t</span></code></dt><dd><p>The type for maps from variable name to variable.</p></dd></dl><dl><dt class="spec value" id="val-_globals"><a href="#val-_globals" class="anchor"></a><code><span class="keyword">val</span> _globals : <span><span>(Base.int, <a href="index.html#type-t">t</a>)</span> Base.Hashtbl.t</span></code></dt><dd><p>Table of all the PMRS in the file, indexed by the function variable id.</p></dd></dl><dl><dt class="spec value" id="val-find_by_name"><a href="#val-find_by_name" class="anchor"></a><code><span class="keyword">val</span> find_by_name : Base.string <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.option</span></code></dt><dd><p>Find a PMRS by name. The name of a PMRS is the name of its pvar.</p></dd></dl><dl><dt class="spec value" id="val-_nonterminals"><a href="#val-_nonterminals" class="anchor"></a><code><span class="keyword">val</span> _nonterminals : <span><span>(Base.int, <a href="index.html#type-t">t</a>)</span> Base.Hashtbl.t</span></code></dt><dd><p>Mapping nonterminals to the PMRS they belong to, index by the nonterminal variable id.</p></dd></dl><dl><dt class="spec value" id="val-find_nonterminal_by_name"><a href="#val-find_nonterminal_by_name" class="anchor"></a><code><span class="keyword">val</span> find_nonterminal_by_name : Base.string <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.option</span></code></dt><dd><p>Find a non-terminal (represented by a variable) from its name.</p></dd></dl><dl><dt class="spec value" id="val-lhs"><a href="#val-lhs" class="anchor"></a><code><span class="keyword">val</span> lhs : <span>(<a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.List.t</span> * <span><span>(Base.string * <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.list</span>)</span> option</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a></code></dt><dd><p>Generate the term that corresponds to the left hand side of a rewrite rule in a PMRS.</p></dd></dl><dl><dt class="spec value" id="val-reinit"><a href="#val-reinit" class="anchor"></a><code><span class="keyword">val</span> reinit : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Reinitialize tables of PMRS and nonterminals.</p></dd></dl><dl><dt class="spec value" id="val-pp_pattern"><a href="#val-pp_pattern" class="anchor"></a><code><span class="keyword">val</span> pp_pattern : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp_rewrite_rule"><a href="#val-pp_rewrite_rule" class="anchor"></a><code><span class="keyword">val</span> pp_rewrite_rule : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-rewrite_rule">rewrite_rule</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-pp_ocaml"><a href="#val-pp_ocaml" class="anchor"></a><code><span class="keyword">val</span> pp_ocaml : Base.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p>Pretty-print a PMRS as a set of OCaml functions.</p></dd></dl><dl><dt class="spec value" id="val-update_order"><a href="#val-update_order" class="anchor"></a><code><span class="keyword">val</span> update_order : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update the order of the pmrs.</p></dd></dl><dl><dt class="spec value" id="val-clear_pmrs_types"><a href="#val-clear_pmrs_types" class="anchor"></a><code><span class="keyword">val</span> clear_pmrs_types : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Clear the type information stored in the different components of the PMRS. Clears the type information of:</p><ul><li>the local variables in each rule of the PMRS.</li><li>the pvar of the PMRS,</li><li>the pmain_symb of the PMRS,</li><li>the unknowns in the PMRS.</li></ul></dd></dl><dl><dt class="spec value" id="val-infer_pmrs_types"><a href="#val-infer_pmrs_types" class="anchor"></a><code><span class="keyword">val</span> infer_pmrs_types : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-unify_two_with_update"><a href="#val-unify_two_with_update" class="anchor"></a><code><span class="keyword">val</span> unify_two_with_update : <span>(<a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> * <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>)</span> <span>&#45;&gt;</span> <span>(<a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> * <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>)</span> <span>&#45;&gt;</span> Base.unit</code></dt><dt class="spec value" id="val-unify_one_with_update"><a href="#val-unify_one_with_update" class="anchor"></a><code><span class="keyword">val</span> unify_one_with_update : <span>(<a href="../Lang/RType/index.html#type-t">Lang.RType.t</a> * <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a>)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-extract_rec_input_typ"><a href="#val-extract_rec_input_typ" class="anchor"></a><code><span class="keyword">val</span> extract_rec_input_typ : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Lang/RType/index.html#type-t">Lang.RType.t</a></code></dt><dt class="spec value" id="val-func_to_pmrs"><a href="#val-func_to_pmrs" class="anchor"></a><code><span class="keyword">val</span> func_to_pmrs : <a href="../Lang/Term/Variable/index.html#type-t">Lang.Term.Variable.t</a> <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-fpattern">Lang.Term.fpattern</a> Base.list</span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-build_match_cases"><a href="#val-build_match_cases" class="anchor"></a><code><span class="keyword">val</span> build_match_cases : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.List.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-rewrite_rule">rewrite_rule</a> Base.list</span> <span>&#45;&gt;</span> <span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <span><a href="../Lang/Term/index.html#type-match_case">Lang.Term.match_case</a> Base.list</span>)</span> Base.option</span></code></dt><dt class="spec value" id="val-single_rule_case"><a href="#val-single_rule_case" class="anchor"></a><code><span class="keyword">val</span> single_rule_case : <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.List.t</span> <span>&#45;&gt;</span> <span>(<span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.List.t</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a></code></dt><dt class="spec value" id="val-vars_and_formals"><a href="#val-vars_and_formals" class="anchor"></a><code><span class="keyword">val</span> vars_and_formals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> <span>&#45;&gt;</span> <span><a href="../Lang__Term/index.html#type-variable">Lang__Term.variable</a> Base.List.t</span></code></dt><dt class="spec value" id="val-func_of_pmrs"><a href="#val-func_of_pmrs" class="anchor"></a><code><span class="keyword">val</span> func_of_pmrs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-function_descr">Lang.Term.function_descr</a> Base.list</span></code></dt><dt class="spec value" id="val-inverted_rule_lookup"><a href="#val-inverted_rule_lookup" class="anchor"></a><code><span class="keyword">val</span> inverted_rule_lookup : <span>?&#8288;boundvars:<span><span>(<a href="../Lang__Term/Variable/index.html#type-t">Lang__Term.Variable.t</a>, <a href="../Lang__Term/Variable/index.html#type-comparator_witness">Lang__Term.Variable.comparator_witness</a>)</span> Base.Set.t</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> * <span><a href="../Lang/Term/index.html#type-variable">Lang.Term.variable</a> Base.List.t</span> * <span><span>(Base.string * <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.list</span>)</span> option</span> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>, <span class="type-var">'b</span>)</span> Base.Map.t</span> <span>&#45;&gt;</span> <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> <span>&#45;&gt;</span> <span><a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> Base.list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>, <span class="type-var">'b</span>)</span> Base.Map.t</span></code></dt><dd><p>inverted_rule_lookup searches for rules whose rhs match (func args), and return a map from rule id to the lhs of the rules matching (func args), with the appropriate substitutions performed.</p></dd></dl><dl><dt class="spec value" id="val-subst_rule_rhs"><a href="#val-subst_rule_rhs" class="anchor"></a><code><span class="keyword">val</span> subst_rule_rhs : <span>p:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../Lang/Term/index.html#type-term">Lang.Term.term</a> * <a href="../Lang/Term/index.html#type-term">Lang.Term.term</a>)</span> Base.list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a substitution to all the right hand side of the PMRS rules.</p></dd></dl><dl><dt class="spec value" id="val-depends"><a href="#val-depends" class="anchor"></a><code><span class="keyword">val</span> depends : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.list</span></code></dt><dd><p>Given an input PMRS, returns a list of PMRS that this PMRS depends on.</p></dd></dl><dl><dt class="spec value" id="val-update_output_type"><a href="#val-update_output_type" class="anchor"></a><code><span class="keyword">val</span> update_output_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Updates and returns the output type of a PMRS.</p></dd></dl></div></body></html>