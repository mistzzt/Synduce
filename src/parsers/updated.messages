main: LET IDENT EQ ABS VBAR
##
## Ends in an error in state: 89.
##
## unary_e -> ABS . unary_e [ VBAR TYPE TIMES RPAR QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LET LE GT GE EQ EOF DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## ABS
##

Message 1.

main: LET IDENT EQ EXCLAMATION VBAR
##
## Ends in an error in state: 79.
##
## unary_e -> EXCLAMATION . unary_e [ VBAR TYPE TIMES RPAR QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LET LE GT GE EQ EOF DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## EXCLAMATION
##

<TEST>

main: LET IDENT EQ FUN IDENT RIGHTARROW VBAR
##
## Ends in an error in state: 88.
##
## expr -> FUN arguments RIGHTARROW . tuple_e [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## FUN arguments RIGHTARROW
##

<TEST>

main: LET IDENT EQ FUN IDENT VBAR
##
## Ends in an error in state: 87.
##
## expr -> FUN arguments . RIGHTARROW tuple_e [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## FUN arguments
##

<TEST>

main: LET IDENT EQ FUN LPAR VBAR
##
## Ends in an error in state: 83.
##
## arguments -> LPAR . separated_nonempty_list(COMMA,IDENT) RPAR [ RIGHTARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: LET IDENT EQ FUN VBAR
##
## Ends in an error in state: 82.
##
## expr -> FUN . arguments RIGHTARROW tuple_e [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## FUN
##

<TEST>

main: LET IDENT EQ MINUS VBAR
##
## Ends in an error in state: 72.
##
## unary_e -> MINUS . unary_e [ VBAR TYPE TIMES RPAR QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LET LE GT GE EQ EOF DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<TEST>

main: LET IDENT EQ TRUE AND VBAR
##
## Ends in an error in state: 119.
##
## logical_and_e -> equality_e AND . logical_and_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## equality_e AND
##

<TEST>

main: LET IDENT EQ TRUE COMMA TRUE COMMA VBAR
##
## Ends in an error in state: 113.
##
## separated_nonempty_list(COMMA,logical_or_e) -> logical_or_e COMMA . separated_nonempty_list(COMMA,logical_or_e) [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_e COMMA
##

<TEST>

main: LET IDENT EQ TRUE COMMA VBAR
##
## Ends in an error in state: 110.
##
## tuple_e -> logical_or_e COMMA . separated_nonempty_list(COMMA,logical_or_e) [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_e COMMA
##

<TEST>

main: LET IDENT EQ TRUE DIV VBAR
##
## Ends in an error in state: 101.
##
## mult_e -> unary_e DIV . mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e DIV
##

<TEST>

main: LET IDENT EQ TRUE EQ CIDENT NEQ
##
## Ends in an error in state: 118.
##
## logical_and_e -> equality_e . AND logical_and_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON ]
## logical_and_e -> equality_e . [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## equality_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production constr_e -> CIDENT
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 134, spurious reduction of production equality_e -> comp_e EQ comp_e
##

<TEST>

main: LET IDENT EQ TRUE EQ VBAR
##
## Ends in an error in state: 133.
##
## equality_e -> comp_e EQ . comp_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e EQ
##

<TEST>

main: LET IDENT EQ TRUE GE CIDENT LT
##
## Ends in an error in state: 121.
##
## equality_e -> comp_e . EQ comp_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON AND ]
## equality_e -> comp_e . NEQ comp_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON AND ]
## equality_e -> comp_e . [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production constr_e -> CIDENT
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 132, spurious reduction of production comp_e -> add_e GE add_e
##

<TEST>

main: LET IDENT EQ TRUE GE VBAR
##
## Ends in an error in state: 131.
##
## comp_e -> add_e GE . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LETPMRS LET EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e GE
##

<TEST>

main: LET IDENT EQ TRUE GT VBAR
##
## Ends in an error in state: 129.
##
## comp_e -> add_e GT . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LETPMRS LET EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e GT
##

<TEST>

main: LET IDENT EQ TRUE LE VBAR
##
## Ends in an error in state: 127.
##
## comp_e -> add_e LE . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LETPMRS LET EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e LE
##

<TEST>

main: LET IDENT EQ TRUE LT VBAR
##
## Ends in an error in state: 125.
##
## comp_e -> add_e LT . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LETPMRS LET EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e LT
##

<TEST>

main: LET IDENT EQ TRUE MINUS VBAR
##
## Ends in an error in state: 107.
##
## add_e -> mult_e MINUS . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## mult_e MINUS
##

<TEST>

main: LET IDENT EQ TRUE MOD VBAR
##
## Ends in an error in state: 99.
##
## mult_e -> unary_e MOD . mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e MOD
##

<TEST>

main: LET IDENT EQ TRUE NEQ VBAR
##
## Ends in an error in state: 122.
##
## equality_e -> comp_e NEQ . comp_e [ VBAR TYPE RPAR QUESTION OR LETPMRS LET EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e NEQ
##

<TEST>

main: LET IDENT EQ TRUE OR VBAR
##
## Ends in an error in state: 116.
##
## logical_or_e -> logical_and_e OR . logical_or_e [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_and_e OR
##

<TEST>

main: LET IDENT EQ TRUE PLUS VBAR
##
## Ends in an error in state: 105.
##
## add_e -> mult_e PLUS . add_e [ VBAR TYPE RPAR QUESTION OR NEQ LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## mult_e PLUS
##

<TEST>

main: LET IDENT EQ TRUE QUESTION TRUE COLON VBAR
##
## Ends in an error in state: 142.
##
## expr -> expr QUESTION expr COLON . expr [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION expr COLON
##

<TEST>

main: LET IDENT EQ TRUE QUESTION TRUE VBAR
##
## Ends in an error in state: 141.
##
## expr -> expr . QUESTION expr COLON expr [ QUESTION COLON ]
## expr -> expr QUESTION expr . COLON expr [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 121, spurious reduction of production equality_e -> comp_e
## In state 118, spurious reduction of production logical_and_e -> equality_e
## In state 115, spurious reduction of production logical_or_e -> logical_and_e
## In state 109, spurious reduction of production tuple_e -> logical_or_e
## In state 135, spurious reduction of production expr -> tuple_e
##

<TEST>

main: LET IDENT EQ TRUE QUESTION VBAR
##
## Ends in an error in state: 140.
##
## expr -> expr QUESTION . expr COLON expr [ VBAR TYPE RPAR QUESTION LETPMRS LET EOF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION
##

<TEST>

main: LET IDENT EQ TRUE RIGHTARROW
##
## Ends in an error in state: 96.
##
## mult_e -> unary_e . DIV mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
## mult_e -> unary_e . TIMES mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
## mult_e -> unary_e . MOD mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
## mult_e -> unary_e . [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
##

<TEST>

main: LET IDENT EQ TRUE TIMES VBAR
##
## Ends in an error in state: 97.
##
## mult_e -> unary_e TIMES . mult_e [ VBAR TYPE RPAR QUESTION PLUS OR NEQ MINUS LT LETPMRS LET LE GT GE EQ EOF COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e TIMES
##

<TEST>

main: LET IDENT EQ TRUE VBAR
##
## Ends in an error in state: 172.
##
## decl -> LET IDENT list(IDENT) EQ expr . [ TYPE LETPMRS LET EOF ]
## expr -> expr . QUESTION expr COLON expr [ TYPE QUESTION LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 121, spurious reduction of production equality_e -> comp_e
## In state 118, spurious reduction of production logical_and_e -> equality_e
## In state 115, spurious reduction of production logical_or_e -> logical_and_e
## In state 109, spurious reduction of production tuple_e -> logical_or_e
## In state 135, spurious reduction of production expr -> tuple_e
##

<TEST>

main: LET IDENT EQ VBAR
##
## Ends in an error in state: 171.
##
## decl -> LET IDENT list(IDENT) EQ . expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) EQ
##

<TEST>

main: LET IDENT VBAR
##
## Ends in an error in state: 169.
##
## decl -> LET IDENT . list(IDENT) EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT
##

<TEST>

main: LET VBAR
##
## Ends in an error in state: 168.
##
## decl -> LET . IDENT list(IDENT) EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET
##

<TEST>

main: LETPMRS IDENT EQ CIDENT LPAR TRUE VBAR
##
## Ends in an error in state: 139.
##
## expr -> expr . QUESTION expr COLON expr [ RPAR QUESTION COMMA ]
## separated_nonempty_list(COMMA,expr) -> expr . [ RPAR ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 121, spurious reduction of production equality_e -> comp_e
## In state 118, spurious reduction of production logical_and_e -> equality_e
## In state 115, spurious reduction of production logical_or_e -> logical_and_e
## In state 109, spurious reduction of production tuple_e -> logical_or_e
## In state 135, spurious reduction of production expr -> tuple_e
##

<TEST>

main: LETPMRS IDENT EQ CIDENT LPAR VBAR
##
## Ends in an error in state: 81.
##
## constr_e -> CIDENT LPAR . loption(separated_nonempty_list(COMMA,expr)) RPAR [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## CIDENT LPAR
##

<TEST>

main: LETPMRS IDENT EQ CIDENT PIDENT
##
## Ends in an error in state: 80.
##
## constr_e -> CIDENT . LPAR loption(separated_nonempty_list(COMMA,expr)) RPAR [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
## constr_e -> CIDENT . [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## CIDENT
##

<TEST>

main: LETPMRS IDENT EQ LPAR TRUE VBAR
##
## Ends in an error in state: 148.
##
## expr -> expr . QUESTION expr COLON expr [ RPAR QUESTION ]
## primary_e -> LPAR expr . RPAR [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 121, spurious reduction of production equality_e -> comp_e
## In state 118, spurious reduction of production logical_and_e -> equality_e
## In state 115, spurious reduction of production logical_or_e -> logical_and_e
## In state 109, spurious reduction of production tuple_e -> logical_or_e
## In state 135, spurious reduction of production expr -> tuple_e
##

<TEST>

main: LETPMRS IDENT EQ LPAR VBAR
##
## Ends in an error in state: 71.
##
## primary_e -> LPAR . expr RPAR [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: LETPMRS IDENT EQ MAX TRUE VBAR
##
## Ends in an error in state: 77.
##
## fun_app_e -> MAX primary_e . primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## MAX primary_e
##

<TEST>

main: LETPMRS IDENT EQ MAX VBAR
##
## Ends in an error in state: 73.
##
## fun_app_e -> MAX . primary_e primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## MAX
##

<TEST>

main: LETPMRS IDENT EQ MIN TRUE VBAR
##
## Ends in an error in state: 150.
##
## fun_app_e -> MIN primary_e . primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## MIN primary_e
##

<TEST>

main: LETPMRS IDENT EQ MIN VBAR
##
## Ends in an error in state: 70.
##
## fun_app_e -> MIN . primary_e primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## MIN
##

<TEST>

main: LETPMRS IDENT EQ RIGHTARROW CIDENT VBAR VBAR
##
## Ends in an error in state: 154.
##
## separated_nonempty_list(VBAR,prule) -> prule VBAR . separated_nonempty_list(VBAR,prule) [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## prule VBAR
##

<TEST>

main: LETPMRS IDENT EQ RIGHTARROW TRUE RPAR
##
## Ends in an error in state: 158.
##
## expr -> expr . QUESTION expr COLON expr [ VBAR TYPE QUESTION LETPMRS LET EOF ]
## prule -> list(constr_e) RIGHTARROW expr . [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## list(constr_e) RIGHTARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
## In state 95, spurious reduction of production unary_e -> constr_e
## In state 96, spurious reduction of production mult_e -> unary_e
## In state 104, spurious reduction of production add_e -> mult_e
## In state 124, spurious reduction of production comp_e -> add_e
## In state 121, spurious reduction of production equality_e -> comp_e
## In state 118, spurious reduction of production logical_and_e -> equality_e
## In state 115, spurious reduction of production logical_or_e -> logical_and_e
## In state 109, spurious reduction of production tuple_e -> logical_or_e
## In state 135, spurious reduction of production expr -> tuple_e
##

<TEST>

main: LETPMRS IDENT EQ RIGHTARROW VBAR
##
## Ends in an error in state: 157.
##
## prule -> list(constr_e) RIGHTARROW . expr [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## list(constr_e) RIGHTARROW
##

<TEST>

main: LETPMRS IDENT EQ TRUE PIDENT
##
## Ends in an error in state: 91.
##
## fun_app_e -> primary_e . primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
## fun_app_e -> primary_e . [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<TEST>

main: LETPMRS IDENT EQ TRUE TRUE PIDENT
##
## Ends in an error in state: 93.
##
## constr_e -> fun_app_e . [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
## fun_app_e -> fun_app_e . primary_e [ VBAR TYPE TRUE TIMES RPAR RIGHTARROW QUESTION PLUS OR NEQ MOD MINUS MIN MAX LT LPAR LETPMRS LET LE INT IDENT GT GE FALSE EQ EOF DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## fun_app_e
##

<TEST>

main: LETPMRS IDENT EQ TRUE VBAR
##
## Ends in an error in state: 159.
##
## list(constr_e) -> constr_e . list(constr_e) [ RIGHTARROW ]
##
## The known suffix of the stack is as follows:
## constr_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production fun_app_e -> primary_e
## In state 93, spurious reduction of production constr_e -> fun_app_e
##

<TEST>

main: LETPMRS IDENT EQ VBAR
##
## Ends in an error in state: 165.
##
## pmrsdecl -> IDENT list(IDENT) EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) EQ
##

<TEST>

main: LETPMRS IDENT IDENT VBAR
##
## Ends in an error in state: 65.
##
## list(IDENT) -> IDENT . list(IDENT) [ EQ ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<TEST>

main: LETPMRS IDENT VBAR
##
## Ends in an error in state: 163.
##
## pmrsdecl -> IDENT . list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<TEST>

main: LETPMRS LPAR IDENT COMMA VBAR
##
## Ends in an error in state: 59.
##
## separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA . separated_nonempty_list(COMMA,IDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## IDENT COMMA
##

<TEST>

main: LETPMRS LPAR IDENT VBAR
##
## Ends in an error in state: 58.
##
## separated_nonempty_list(COMMA,IDENT) -> IDENT . [ RPAR ]
## separated_nonempty_list(COMMA,IDENT) -> IDENT . COMMA separated_nonempty_list(COMMA,IDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<TEST>

main: LETPMRS LPAR RPAR IDENT EQ VBAR
##
## Ends in an error in state: 68.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ
##

<TEST>

main: LETPMRS LPAR RPAR IDENT VBAR
##
## Ends in an error in state: 64.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT . list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT
##

<TEST>

main: LETPMRS LPAR RPAR VBAR
##
## Ends in an error in state: 63.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR . IDENT list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR
##

<TEST>

main: LETPMRS LPAR VBAR
##
## Ends in an error in state: 57.
##
## pmrsdecl -> LPAR . loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: LETPMRS VBAR
##
## Ends in an error in state: 56.
##
## decl -> LETPMRS . pmrsdecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LETPMRS
##

<TEST>

main: TYPE IDENT EQ CIDENT OF PIDENT TIMES PIDENT TIMES VBAR
##
## Ends in an error in state: 29.
##
## separated_nonempty_list(TIMES,typefun) -> typefun TIMES . separated_nonempty_list(TIMES,typefun) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun TIMES
##

<TEST>

main: TYPE IDENT EQ CIDENT OF PIDENT TIMES TRUE
##
## Ends in an error in state: 27.
##
## typeconstr -> CIDENT OF typefun TIMES . loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT OF typefun TIMES
##

<TEST>

main: TYPE IDENT EQ CIDENT OF VBAR
##
## Ends in an error in state: 25.
##
## typeconstr -> CIDENT OF . typefun [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT OF . typefun TIMES loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT OF
##

<TEST>

main: TYPE IDENT EQ CIDENT TRUE
##
## Ends in an error in state: 24.
##
## typeconstr -> CIDENT . OF typefun [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT . OF typefun TIMES loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT . [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT
##

<TEST>

main: TYPE IDENT EQ CIDENT VBAR VBAR
##
## Ends in an error in state: 39.
##
## separated_nonempty_list(VBAR,typeconstr) -> typeconstr VBAR . separated_nonempty_list(VBAR,typeconstr) [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typeconstr VBAR
##

<TEST>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT COMMA VBAR
##
## Ends in an error in state: 19.
##
## separated_nonempty_list(COMMA,typeapp) -> typeapp COMMA . separated_nonempty_list(COMMA,typeapp) [ RPAR ]
##
## The known suffix of the stack is as follows:
## typeapp COMMA
##

<TEST>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT RPAR VBAR
##
## Ends in an error in state: 22.
##
## typeapp -> LPAR typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR . typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR
##

<TEST>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT VBAR
##
## Ends in an error in state: 18.
##
## separated_nonempty_list(COMMA,typeapp) -> typeapp . [ RPAR ]
## separated_nonempty_list(COMMA,typeapp) -> typeapp . COMMA separated_nonempty_list(COMMA,typeapp) [ RPAR ]
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<TEST>

main: TYPE IDENT EQ LPAR PIDENT COMMA VBAR
##
## Ends in an error in state: 17.
##
## typeapp -> LPAR typeapp COMMA . separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp COMMA
##

<TEST>

main: TYPE IDENT EQ LPAR PIDENT VBAR
##
## Ends in an error in state: 16.
##
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT COMMA BOOLSORT ]
## typeapp -> LPAR typeapp . COMMA separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typetermb -> LPAR typeapp . RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<TEST>

main: TYPE IDENT EQ LPAR VBAR
##
## Ends in an error in state: 6.
##
## typeapp -> LPAR . typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typetermb -> LPAR . typeapp RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: TYPE IDENT EQ PIDENT LPAR PIDENT VBAR
##
## Ends in an error in state: 12.
##
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT BOOLSORT ]
## typetermb -> LPAR typeapp . RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<TEST>

main: TYPE IDENT EQ PIDENT LPAR VBAR
##
## Ends in an error in state: 11.
##
## typetermb -> LPAR . typeapp RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: TYPE IDENT EQ PIDENT RIGHTARROW PIDENT RPAR
##
## Ends in an error in state: 33.
##
## typeapp -> typeapp . typetermb [ VBAR TYPE TIMES RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF BOOLSORT ]
## typefun -> typefun RIGHTARROW typeapp . [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun RIGHTARROW typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<TEST>

main: TYPE IDENT EQ PIDENT RIGHTARROW VBAR
##
## Ends in an error in state: 32.
##
## typefun -> typefun RIGHTARROW . typeapp [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun RIGHTARROW
##

<TEST>

main: TYPE IDENT EQ PIDENT RPAR
##
## Ends in an error in state: 30.
##
## typeapp -> typeapp . typetermb [ VBAR TYPE TIMES RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF BOOLSORT ]
## typefun -> typeapp . [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<TEST>

main: TYPE IDENT EQ PIDENT TRUE
##
## Ends in an error in state: 10.
##
## typeapp -> typetermb . typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typeapp -> typetermb . [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## typetermb
##

<TEST>

main: TYPE IDENT EQ PIDENT VBAR
##
## Ends in an error in state: 37.
##
## typefun -> typefun . RIGHTARROW typeapp [ TYPE RIGHTARROW LETPMRS LET EOF ]
## typeterm0 -> typefun . [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
## In state 30, spurious reduction of production typefun -> typeapp
##

<TEST>

main: TYPE IDENT EQ VBAR
##
## Ends in an error in state: 53.
##
## typedecl -> IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT EQ
##

<TEST>

main: TYPE IDENT VBAR
##
## Ends in an error in state: 52.
##
## typedecl -> IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<TEST>

main: TYPE LPAR PIDENT COMMA VBAR
##
## Ends in an error in state: 44.
##
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT COMMA . separated_nonempty_list(COMMA,PIDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## PIDENT COMMA
##

<TEST>

main: TYPE LPAR PIDENT VBAR
##
## Ends in an error in state: 43.
##
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT . [ RPAR ]
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT . COMMA separated_nonempty_list(COMMA,PIDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## PIDENT
##

<TEST>

main: TYPE LPAR RPAR IDENT EQ VBAR
##
## Ends in an error in state: 50.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ
##

<TEST>

main: TYPE LPAR RPAR IDENT VBAR
##
## Ends in an error in state: 49.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT
##

<TEST>

main: TYPE LPAR RPAR VBAR
##
## Ends in an error in state: 48.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR . IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR
##

<TEST>

main: TYPE LPAR VBAR
##
## Ends in an error in state: 42.
##
## typedecl -> LPAR . loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<TEST>

main: TYPE PIDENT IDENT EQ VBAR
##
## Ends in an error in state: 4.
##
## typedecl -> PIDENT IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT IDENT EQ
##

<TEST>

main: TYPE PIDENT IDENT VBAR
##
## Ends in an error in state: 3.
##
## typedecl -> PIDENT IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT IDENT
##

<TEST>

main: TYPE PIDENT VBAR
##
## Ends in an error in state: 2.
##
## typedecl -> PIDENT . IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT
##

<TEST>

main: TYPE VBAR
##
## Ends in an error in state: 1.
##
## decl -> TYPE . typedecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<TEST>

main: VBAR
##
## Ends in an error in state: 0.
##
## main' -> . main [ # ]
##
## The known suffix of the stack is as follows:
##
##

<TEST>

