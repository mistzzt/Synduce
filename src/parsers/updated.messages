main: LET IDENT EQ TRUE VBAR
##
## Ends in an error in state: 238.
##
## decl -> LET IDENT list(IDENT) EQ expr . [ TYPE LETPMRS LET EOF ]
## expr -> expr . QUESTION expr COLON expr [ TYPE QUESTION LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT EQ VBAR
##
## Ends in an error in state: 237.
##
## decl -> LET IDENT list(IDENT) EQ . expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT IDENT RBRACKET
##
## Ends in an error in state: 231.
##
## decl -> LET IDENT list(IDENT) . LBRACE expr RBRACE EQ expr [ TYPE LETPMRS LET EOF ]
## decl -> LET IDENT list(IDENT) . EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 65, spurious reduction of production list(IDENT) ->
## In state 66, spurious reduction of production list(IDENT) -> IDENT list(IDENT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT LBRACE TRUE RBRACE EQ TRUE VBAR
##
## Ends in an error in state: 236.
##
## decl -> LET IDENT list(IDENT) LBRACE expr RBRACE EQ expr . [ TYPE LETPMRS LET EOF ]
## expr -> expr . QUESTION expr COLON expr [ TYPE QUESTION LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) LBRACE expr RBRACE EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT LBRACE TRUE RBRACE EQ VBAR
##
## Ends in an error in state: 235.
##
## decl -> LET IDENT list(IDENT) LBRACE expr RBRACE EQ . expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) LBRACE expr RBRACE EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT LBRACE TRUE RBRACE VBAR
##
## Ends in an error in state: 234.
##
## decl -> LET IDENT list(IDENT) LBRACE expr RBRACE . EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) LBRACE expr RBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT LBRACE TRUE VBAR
##
## Ends in an error in state: 233.
##
## decl -> LET IDENT list(IDENT) LBRACE expr . RBRACE EQ expr [ TYPE LETPMRS LET EOF ]
## expr -> expr . QUESTION expr COLON expr [ RBRACE QUESTION ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) LBRACE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT LBRACE VBAR
##
## Ends in an error in state: 232.
##
## decl -> LET IDENT list(IDENT) LBRACE . expr RBRACE EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT list(IDENT) LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET IDENT VBAR
##
## Ends in an error in state: 230.
##
## decl -> LET IDENT . list(IDENT) LBRACE expr RBRACE EQ expr [ TYPE LETPMRS LET EOF ]
## decl -> LET IDENT . list(IDENT) EQ expr [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ CIDENT LETAND VBAR
##
## Ends in an error in state: 228.
##
## separated_nonempty_list(LETAND,functdecl) -> functdecl LETAND . separated_nonempty_list(LETAND,functdecl) [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## functdecl LETAND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION TRUE RIGHTARROW CIDENT VBAR VBAR
##
## Ends in an error in state: 207.
##
## separated_nonempty_list(VBAR,frule) -> frule VBAR . separated_nonempty_list(VBAR,frule) [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## frule VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION TRUE RIGHTARROW TRUE THEN
##
## Ends in an error in state: 205.
##
## expr -> expr . QUESTION expr COLON expr [ VBAR TYPE QUESTION LETPMRS LETAND LET LBRACKET EOF ]
## frule -> primary_e RIGHTARROW expr . [ VBAR TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## primary_e RIGHTARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION TRUE RIGHTARROW VBAR
##
## Ends in an error in state: 204.
##
## frule -> primary_e RIGHTARROW . expr [ VBAR TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## primary_e RIGHTARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION TRUE VBAR
##
## Ends in an error in state: 203.
##
## frule -> primary_e . RIGHTARROW expr [ VBAR TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION TYPE
##
## Ends in an error in state: 200.
##
## function_body -> FUNCTION . VBAR separated_nonempty_list(VBAR,frule) [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
## function_body -> FUNCTION . separated_nonempty_list(VBAR,frule) [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ FUNCTION VBAR VBAR
##
## Ends in an error in state: 201.
##
## function_body -> FUNCTION VBAR . separated_nonempty_list(VBAR,frule) [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## FUNCTION VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ TRUE VBAR
##
## Ends in an error in state: 211.
##
## expr -> expr . QUESTION expr COLON expr [ TYPE QUESTION LETPMRS LETAND LET LBRACKET EOF ]
## function_body -> expr . [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT EQ VBAR
##
## Ends in an error in state: 199.
##
## functdecl -> IDENT list(IDENT) EQ . function_body [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT IDENT RBRACKET
##
## Ends in an error in state: 198.
##
## functdecl -> IDENT list(IDENT) . EQ function_body [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 65, spurious reduction of production list(IDENT) ->
## In state 66, spurious reduction of production list(IDENT) -> IDENT list(IDENT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC IDENT VBAR
##
## Ends in an error in state: 197.
##
## functdecl -> IDENT . list(IDENT) EQ function_body [ TYPE LETPMRS LETAND LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING IDENT LBRACE
##
## Ends in an error in state: 219.
##
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET DEFINING list(IDENT) . RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET DEFINING list(IDENT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 65, spurious reduction of production list(IDENT) ->
## In state 66, spurious reduction of production list(IDENT) -> IDENT list(IDENT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET ELSE
##
## Ends in an error in state: 221.
##
## decl -> LET REC letpmrsdecl . LBRACKET EQUIV IDENT IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
## decl -> LET REC letpmrsdecl . [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC letpmrsdecl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET LBRACKET EQUIV IDENT IDENT RBRACKET VBAR
##
## Ends in an error in state: 242.
##
## list(decl) -> decl . list(decl) [ EOF ]
##
## The known suffix of the stack is as follows:
## decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET LBRACKET EQUIV IDENT IDENT VBAR
##
## Ends in an error in state: 225.
##
## decl -> LET REC letpmrsdecl LBRACKET EQUIV IDENT IDENT . RBRACKET [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC letpmrsdecl LBRACKET EQUIV IDENT IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET LBRACKET EQUIV IDENT VBAR
##
## Ends in an error in state: 224.
##
## decl -> LET REC letpmrsdecl LBRACKET EQUIV IDENT . IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC letpmrsdecl LBRACKET EQUIV IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET LBRACKET EQUIV VBAR
##
## Ends in an error in state: 223.
##
## decl -> LET REC letpmrsdecl LBRACKET EQUIV . IDENT IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC letpmrsdecl LBRACKET EQUIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING RBRACKET LBRACKET VBAR
##
## Ends in an error in state: 222.
##
## decl -> LET REC letpmrsdecl LBRACKET . EQUIV IDENT IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC letpmrsdecl LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET DEFINING VBAR
##
## Ends in an error in state: 218.
##
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET DEFINING . list(IDENT) RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET DEFINING
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET INVARIANT TRUE VBAR
##
## Ends in an error in state: 216.
##
## expr -> expr . QUESTION expr COLON expr [ RBRACKET QUESTION ]
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET INVARIANT expr . RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET INVARIANT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET INVARIANT VBAR
##
## Ends in an error in state: 215.
##
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET INVARIANT . expr RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET INVARIANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC LBRACKET VBAR
##
## Ends in an error in state: 214.
##
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET . DEFINING list(IDENT) RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
## letpmrsdecl -> loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET . INVARIANT expr RBRACKET [ TYPE LETPMRS LET LBRACKET EOF ]
##
## The known suffix of the stack is as follows:
## loption(separated_nonempty_list(LETAND,functdecl)) LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET REC VBAR
##
## Ends in an error in state: 196.
##
## decl -> LET REC . letpmrsdecl LBRACKET EQUIV IDENT IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
## decl -> LET REC . letpmrsdecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET REC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LET VBAR
##
## Ends in an error in state: 195.
##
## decl -> LET . IDENT list(IDENT) LBRACE expr RBRACE EQ expr [ TYPE LETPMRS LET EOF ]
## decl -> LET . IDENT list(IDENT) EQ expr [ TYPE LETPMRS LET EOF ]
## decl -> LET . REC letpmrsdecl LBRACKET EQUIV IDENT IDENT RBRACKET [ TYPE LETPMRS LET EOF ]
## decl -> LET . REC letpmrsdecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT EQ TRUE RIGHTARROW CIDENT VBAR VBAR
##
## Ends in an error in state: 176.
##
## separated_nonempty_list(VBAR,prule) -> prule VBAR . separated_nonempty_list(VBAR,prule) [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## prule VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT EQ TRUE RIGHTARROW TRUE THEN
##
## Ends in an error in state: 180.
##
## expr -> expr . QUESTION expr COLON expr [ VBAR TYPE QUESTION LETPMRS LET EOF ]
## prule -> fun_app_e RIGHTARROW expr . [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## fun_app_e RIGHTARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT EQ TRUE RIGHTARROW VBAR
##
## Ends in an error in state: 179.
##
## prule -> fun_app_e RIGHTARROW . expr [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## fun_app_e RIGHTARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT EQ TRUE VBAR
##
## Ends in an error in state: 178.
##
## prule -> fun_app_e . RIGHTARROW expr [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## fun_app_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT EQ VBAR
##
## Ends in an error in state: 192.
##
## pmrsdecl -> IDENT list(IDENT) EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT IDENT RBRACKET
##
## Ends in an error in state: 186.
##
## pmrsdecl -> IDENT list(IDENT) . EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> IDENT list(IDENT) . LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 65, spurious reduction of production list(IDENT) ->
## In state 66, spurious reduction of production list(IDENT) -> IDENT list(IDENT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT IDENT VBAR
##
## Ends in an error in state: 65.
##
## list(IDENT) -> IDENT . list(IDENT) [ RBRACKET LBRACE EQ ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE ABS VBAR
##
## Ends in an error in state: 101.
##
## unary_e -> ABS . unary_e [ VBAR TYPE TIMES THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## ABS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE CIDENT LPAR TRUE COMMA VBAR
##
## Ends in an error in state: 87.
##
## separated_nonempty_list(COMMA,fun_app_e) -> fun_app_e COMMA . separated_nonempty_list(COMMA,fun_app_e) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_app_e COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE CIDENT LPAR TRUE VBAR
##
## Ends in an error in state: 86.
##
## separated_nonempty_list(COMMA,fun_app_e) -> fun_app_e . [ RPAR ]
## separated_nonempty_list(COMMA,fun_app_e) -> fun_app_e . COMMA separated_nonempty_list(COMMA,fun_app_e) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_app_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE CIDENT LPAR VBAR
##
## Ends in an error in state: 78.
##
## primary_e -> CIDENT LPAR . loption(separated_nonempty_list(COMMA,fun_app_e)) RPAR [ VBAR TYPE TRUE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LPAR LETPMRS LETAND LET LE LBRACKET INT IN IDENT GT GE FALSE EQ EOF ELSE DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## CIDENT LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE CIDENT REC
##
## Ends in an error in state: 77.
##
## primary_e -> CIDENT . LPAR loption(separated_nonempty_list(COMMA,fun_app_e)) RPAR [ VBAR TYPE TRUE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LPAR LETPMRS LETAND LET LE LBRACKET INT IN IDENT GT GE FALSE EQ EOF ELSE DIV COMMA COLON CIDENT AND ]
## primary_e -> CIDENT . [ VBAR TYPE TRUE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LPAR LETPMRS LETAND LET LE LBRACKET INT IN IDENT GT GE FALSE EQ EOF ELSE DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## CIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE EXCLAMATION VBAR
##
## Ends in an error in state: 100.
##
## unary_e -> EXCLAMATION . unary_e [ VBAR TYPE TIMES THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## EXCLAMATION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE FUN RIGHTARROW VBAR
##
## Ends in an error in state: 99.
##
## expr -> FUN list(primary_e) RIGHTARROW . tuple_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## FUN list(primary_e) RIGHTARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE FUN TRUE VBAR
##
## Ends in an error in state: 96.
##
## list(primary_e) -> primary_e . list(primary_e) [ RIGHTARROW ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE FUN VBAR
##
## Ends in an error in state: 95.
##
## expr -> FUN . list(primary_e) RIGHTARROW tuple_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## FUN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE IF TRUE THEN TRUE ELSE VBAR
##
## Ends in an error in state: 152.
##
## expr -> IF expr THEN expr ELSE . expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## IF expr THEN expr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE IF TRUE THEN TRUE VBAR
##
## Ends in an error in state: 147.
##
## expr -> expr . QUESTION expr COLON expr [ QUESTION ELSE ]
## expr -> IF expr THEN expr . ELSE expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## IF expr THEN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE IF TRUE THEN VBAR
##
## Ends in an error in state: 146.
##
## expr -> IF expr THEN . expr ELSE expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## IF expr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE IF TRUE VBAR
##
## Ends in an error in state: 145.
##
## expr -> expr . QUESTION expr COLON expr [ THEN QUESTION ]
## expr -> IF expr . THEN expr ELSE expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## IF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE IF VBAR
##
## Ends in an error in state: 94.
##
## expr -> IF . expr THEN expr ELSE expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA TRUE COMMA VBAR
##
## Ends in an error in state: 164.
##
## separated_nonempty_list(COMMA,primary_e) -> primary_e COMMA . separated_nonempty_list(COMMA,primary_e) [ EQ ]
##
## The known suffix of the stack is as follows:
## primary_e COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA TRUE EQ TRUE IN VBAR
##
## Ends in an error in state: 161.
##
## expr -> LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ expr IN . expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ expr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA TRUE EQ TRUE VBAR
##
## Ends in an error in state: 160.
##
## expr -> LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ expr . IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
## expr -> expr . QUESTION expr COLON expr [ QUESTION IN ]
##
## The known suffix of the stack is as follows:
## LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA TRUE EQ VBAR
##
## Ends in an error in state: 159.
##
## expr -> LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ . expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA TRUE VBAR
##
## Ends in an error in state: 163.
##
## separated_nonempty_list(COMMA,primary_e) -> primary_e . [ EQ ]
## separated_nonempty_list(COMMA,primary_e) -> primary_e . COMMA separated_nonempty_list(COMMA,primary_e) [ EQ ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE COMMA VBAR
##
## Ends in an error in state: 157.
##
## expr -> LET primary_e COMMA . separated_nonempty_list(COMMA,primary_e) EQ expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE EQ TRUE IN VBAR
##
## Ends in an error in state: 155.
##
## expr -> LET primary_e EQ expr IN . expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e EQ expr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE EQ TRUE VBAR
##
## Ends in an error in state: 154.
##
## expr -> LET primary_e EQ expr . IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
## expr -> expr . QUESTION expr COLON expr [ QUESTION IN ]
##
## The known suffix of the stack is as follows:
## LET primary_e EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE EQ VBAR
##
## Ends in an error in state: 93.
##
## expr -> LET primary_e EQ . expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET TRUE VBAR
##
## Ends in an error in state: 92.
##
## expr -> LET primary_e . EQ expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
## expr -> LET primary_e . COMMA separated_nonempty_list(COMMA,primary_e) EQ expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LET VBAR
##
## Ends in an error in state: 91.
##
## expr -> LET . primary_e EQ expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
## expr -> LET . primary_e COMMA separated_nonempty_list(COMMA,primary_e) EQ expr IN expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LPAR TRUE VBAR
##
## Ends in an error in state: 166.
##
## expr -> expr . QUESTION expr COLON expr [ RPAR QUESTION ]
## primary_e -> LPAR expr . RPAR [ VBAR TYPE TRUE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LPAR LETPMRS LETAND LET LE LBRACKET INT IN IDENT GT GE FALSE EQ EOF ELSE DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE LPAR VBAR
##
## Ends in an error in state: 72.
##
## primary_e -> LPAR . expr RPAR [ VBAR TYPE TRUE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LPAR LETPMRS LETAND LET LE LBRACKET INT IN IDENT GT GE FALSE EQ EOF ELSE DIV COMMA COLON CIDENT AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE MAX TRUE VBAR
##
## Ends in an error in state: 89.
##
## fun_app_e -> MAX primary_e . primary_e [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MAX primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE MAX VBAR
##
## Ends in an error in state: 73.
##
## fun_app_e -> MAX . primary_e primary_e [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MAX
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE MIN TRUE VBAR
##
## Ends in an error in state: 168.
##
## fun_app_e -> MIN primary_e . primary_e [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MIN primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE MIN VBAR
##
## Ends in an error in state: 71.
##
## fun_app_e -> MIN . primary_e primary_e [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE MINUS VBAR
##
## Ends in an error in state: 70.
##
## unary_e -> MINUS . unary_e [ VBAR TYPE TIMES THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE AND VBAR
##
## Ends in an error in state: 128.
##
## logical_and_e -> equality_e AND . logical_and_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## equality_e AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE COMMA TRUE COMMA VBAR
##
## Ends in an error in state: 122.
##
## separated_nonempty_list(COMMA,logical_or_e) -> logical_or_e COMMA . separated_nonempty_list(COMMA,logical_or_e) [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_e COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE COMMA VBAR
##
## Ends in an error in state: 119.
##
## tuple_e -> logical_or_e COMMA . separated_nonempty_list(COMMA,logical_or_e) [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## logical_or_e COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE DIV VBAR
##
## Ends in an error in state: 110.
##
## mult_e -> unary_e DIV . mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e DIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE EQ CIDENT NEQ
##
## Ends in an error in state: 127.
##
## logical_and_e -> equality_e . AND logical_and_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON ]
## logical_and_e -> equality_e . [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## equality_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 77, spurious reduction of production primary_e -> CIDENT
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 143, spurious reduction of production equality_e -> comp_e EQ comp_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE EQ VBAR
##
## Ends in an error in state: 142.
##
## equality_e -> comp_e EQ . comp_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE GE CIDENT LT
##
## Ends in an error in state: 130.
##
## equality_e -> comp_e . EQ comp_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON AND ]
## equality_e -> comp_e . NEQ comp_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON AND ]
## equality_e -> comp_e . [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 77, spurious reduction of production primary_e -> CIDENT
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 141, spurious reduction of production comp_e -> add_e GE add_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE GE VBAR
##
## Ends in an error in state: 140.
##
## comp_e -> add_e GE . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LETPMRS LETAND LET LBRACKET IN EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e GE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE GT VBAR
##
## Ends in an error in state: 138.
##
## comp_e -> add_e GT . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LETPMRS LETAND LET LBRACKET IN EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE LE VBAR
##
## Ends in an error in state: 136.
##
## comp_e -> add_e LE . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LETPMRS LETAND LET LBRACKET IN EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e LE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE LT VBAR
##
## Ends in an error in state: 134.
##
## comp_e -> add_e LT . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LETPMRS LETAND LET LBRACKET IN EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## add_e LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE MINUS VBAR
##
## Ends in an error in state: 116.
##
## add_e -> mult_e MINUS . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## mult_e MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE MOD VBAR
##
## Ends in an error in state: 108.
##
## mult_e -> unary_e MOD . mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e MOD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE NEQ VBAR
##
## Ends in an error in state: 131.
##
## equality_e -> comp_e NEQ . comp_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## comp_e NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE OR VBAR
##
## Ends in an error in state: 125.
##
## logical_or_e -> logical_and_e OR . logical_or_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## logical_and_e OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE PLUS VBAR
##
## Ends in an error in state: 114.
##
## add_e -> mult_e PLUS . add_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION OR NEQ LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## mult_e PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE QUESTION TRUE COLON VBAR
##
## Ends in an error in state: 150.
##
## expr -> expr QUESTION expr COLON . expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE QUESTION TRUE VBAR
##
## Ends in an error in state: 149.
##
## expr -> expr . QUESTION expr COLON expr [ QUESTION COLON ]
## expr -> expr QUESTION expr . COLON expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE QUESTION VBAR
##
## Ends in an error in state: 148.
##
## expr -> expr QUESTION . expr COLON expr [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION LETPMRS LETAND LET LBRACKET IN EOF ELSE COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE RBRACE EQ VBAR
##
## Ends in an error in state: 190.
##
## pmrsdecl -> IDENT list(IDENT) LBRACE expr RBRACE EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) LBRACE expr RBRACE EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE RBRACE VBAR
##
## Ends in an error in state: 189.
##
## pmrsdecl -> IDENT list(IDENT) LBRACE expr RBRACE . EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) LBRACE expr RBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE REC
##
## Ends in an error in state: 80.
##
## fun_app_e -> primary_e . nonempty_list(primary_e) [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
## fun_app_e -> primary_e . [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE RIGHTARROW
##
## Ends in an error in state: 105.
##
## mult_e -> unary_e . DIV mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
## mult_e -> unary_e . TIMES mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
## mult_e -> unary_e . MOD mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
## mult_e -> unary_e . [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE TIMES VBAR
##
## Ends in an error in state: 106.
##
## mult_e -> unary_e TIMES . mult_e [ VBAR TYPE THEN RPAR RBRACKET RBRACE QUESTION PLUS OR NEQ MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## unary_e TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE TRUE REC
##
## Ends in an error in state: 81.
##
## nonempty_list(primary_e) -> primary_e . [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
## nonempty_list(primary_e) -> primary_e . nonempty_list(primary_e) [ VBAR TYPE TIMES THEN RPAR RIGHTARROW RBRACKET RBRACE QUESTION PLUS OR NEQ MOD MINUS LT LETPMRS LETAND LET LE LBRACKET IN GT GE EQ EOF ELSE DIV COMMA COLON AND ]
##
## The known suffix of the stack is as follows:
## primary_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE TRUE VBAR
##
## Ends in an error in state: 188.
##
## expr -> expr . QUESTION expr COLON expr [ RBRACE QUESTION ]
## pmrsdecl -> IDENT list(IDENT) LBRACE expr . RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) LBRACE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT LBRACE VBAR
##
## Ends in an error in state: 187.
##
## pmrsdecl -> IDENT list(IDENT) LBRACE . expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT list(IDENT) LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS IDENT VBAR
##
## Ends in an error in state: 185.
##
## pmrsdecl -> IDENT . list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> IDENT . list(IDENT) LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR IDENT COMMA VBAR
##
## Ends in an error in state: 59.
##
## separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA . separated_nonempty_list(COMMA,IDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## IDENT COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR IDENT VBAR
##
## Ends in an error in state: 58.
##
## separated_nonempty_list(COMMA,IDENT) -> IDENT . [ RPAR ]
## separated_nonempty_list(COMMA,IDENT) -> IDENT . COMMA separated_nonempty_list(COMMA,IDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT EQ VBAR
##
## Ends in an error in state: 183.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT IDENT RBRACKET
##
## Ends in an error in state: 67.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) . EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) . LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 65, spurious reduction of production list(IDENT) ->
## In state 66, spurious reduction of production list(IDENT) -> IDENT list(IDENT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT LBRACE TRUE RBRACE EQ VBAR
##
## Ends in an error in state: 173.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr RBRACE EQ . pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr RBRACE EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT LBRACE TRUE RBRACE VBAR
##
## Ends in an error in state: 172.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr RBRACE . EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr RBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT LBRACE TRUE VBAR
##
## Ends in an error in state: 171.
##
## expr -> expr . QUESTION expr COLON expr [ RBRACE QUESTION ]
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr . RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production fun_app_e -> primary_e
## In state 103, spurious reduction of production unary_e -> fun_app_e
## In state 105, spurious reduction of production mult_e -> unary_e
## In state 113, spurious reduction of production add_e -> mult_e
## In state 133, spurious reduction of production comp_e -> add_e
## In state 130, spurious reduction of production equality_e -> comp_e
## In state 127, spurious reduction of production logical_and_e -> equality_e
## In state 124, spurious reduction of production logical_or_e -> logical_and_e
## In state 118, spurious reduction of production tuple_e -> logical_or_e
## In state 144, spurious reduction of production expr -> tuple_e
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT LBRACE VBAR
##
## Ends in an error in state: 68.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE . expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR IDENT VBAR
##
## Ends in an error in state: 64.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT . list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT . list(IDENT) LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR RPAR VBAR
##
## Ends in an error in state: 63.
##
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR . IDENT list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR . IDENT list(IDENT) LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,IDENT)) RPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS LPAR VBAR
##
## Ends in an error in state: 57.
##
## pmrsdecl -> LPAR . loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) EQ pbody [ TYPE LETPMRS LET EOF ]
## pmrsdecl -> LPAR . loption(separated_nonempty_list(COMMA,IDENT)) RPAR IDENT list(IDENT) LBRACE expr RBRACE EQ pbody [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: LETPMRS VBAR
##
## Ends in an error in state: 56.
##
## decl -> LETPMRS . pmrsdecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LETPMRS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ CIDENT OF PIDENT TIMES PIDENT TIMES VBAR
##
## Ends in an error in state: 29.
##
## separated_nonempty_list(TIMES,typefun) -> typefun TIMES . separated_nonempty_list(TIMES,typefun) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ CIDENT OF PIDENT TIMES TRUE
##
## Ends in an error in state: 27.
##
## typeconstr -> CIDENT OF typefun TIMES . loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT OF typefun TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ CIDENT OF VBAR
##
## Ends in an error in state: 25.
##
## typeconstr -> CIDENT OF . typefun [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT OF . typefun TIMES loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ CIDENT TRUE
##
## Ends in an error in state: 24.
##
## typeconstr -> CIDENT . OF typefun [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT . OF typefun TIMES loption(separated_nonempty_list(TIMES,typefun)) [ VBAR TYPE LETPMRS LET EOF ]
## typeconstr -> CIDENT . [ VBAR TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## CIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ CIDENT VBAR VBAR
##
## Ends in an error in state: 39.
##
## separated_nonempty_list(VBAR,typeconstr) -> typeconstr VBAR . separated_nonempty_list(VBAR,typeconstr) [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typeconstr VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT COMMA VBAR
##
## Ends in an error in state: 19.
##
## separated_nonempty_list(COMMA,typeapp) -> typeapp COMMA . separated_nonempty_list(COMMA,typeapp) [ RPAR ]
##
## The known suffix of the stack is as follows:
## typeapp COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT RPAR VBAR
##
## Ends in an error in state: 22.
##
## typeapp -> LPAR typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR . typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR PIDENT COMMA PIDENT VBAR
##
## Ends in an error in state: 18.
##
## separated_nonempty_list(COMMA,typeapp) -> typeapp . [ RPAR ]
## separated_nonempty_list(COMMA,typeapp) -> typeapp . COMMA separated_nonempty_list(COMMA,typeapp) [ RPAR ]
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR PIDENT COMMA VBAR
##
## Ends in an error in state: 17.
##
## typeapp -> LPAR typeapp COMMA . separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR PIDENT VBAR
##
## Ends in an error in state: 16.
##
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT COMMA BOOLSORT ]
## typeapp -> LPAR typeapp . COMMA separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typetermb -> LPAR typeapp . RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ LPAR VBAR
##
## Ends in an error in state: 6.
##
## typeapp -> LPAR . typeapp COMMA separated_nonempty_list(COMMA,typeapp) RPAR typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typetermb -> LPAR . typeapp RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT LPAR PIDENT VBAR
##
## Ends in an error in state: 12.
##
## typeapp -> typeapp . typetermb [ RPAR PIDENT LPAR INTSORT IDENT BOOLSORT ]
## typetermb -> LPAR typeapp . RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT LPAR VBAR
##
## Ends in an error in state: 11.
##
## typetermb -> LPAR . typeapp RPAR [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT RIGHTARROW PIDENT RPAR
##
## Ends in an error in state: 33.
##
## typeapp -> typeapp . typetermb [ VBAR TYPE TIMES RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF BOOLSORT ]
## typefun -> typefun RIGHTARROW typeapp . [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun RIGHTARROW typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT RIGHTARROW VBAR
##
## Ends in an error in state: 32.
##
## typefun -> typefun RIGHTARROW . typeapp [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun RIGHTARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT RPAR
##
## Ends in an error in state: 30.
##
## typeapp -> typeapp . typetermb [ VBAR TYPE TIMES RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF BOOLSORT ]
## typefun -> typeapp . [ VBAR TYPE TIMES RIGHTARROW LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typeapp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT TRUE
##
## Ends in an error in state: 10.
##
## typeapp -> typetermb . typetermb [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
## typeapp -> typetermb . [ VBAR TYPE TIMES RPAR RIGHTARROW PIDENT LPAR LETPMRS LET INTSORT IDENT EOF COMMA BOOLSORT ]
##
## The known suffix of the stack is as follows:
## typetermb
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ PIDENT VBAR
##
## Ends in an error in state: 37.
##
## typefun -> typefun . RIGHTARROW typeapp [ TYPE RIGHTARROW LETPMRS LET EOF ]
## typeterm0 -> typefun . [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## typefun
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 10, spurious reduction of production typeapp -> typetermb
## In state 30, spurious reduction of production typefun -> typeapp
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT EQ VBAR
##
## Ends in an error in state: 53.
##
## typedecl -> IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE IDENT VBAR
##
## Ends in an error in state: 52.
##
## typedecl -> IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR PIDENT COMMA VBAR
##
## Ends in an error in state: 44.
##
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT COMMA . separated_nonempty_list(COMMA,PIDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## PIDENT COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR PIDENT VBAR
##
## Ends in an error in state: 43.
##
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT . [ RPAR ]
## separated_nonempty_list(COMMA,PIDENT) -> PIDENT . COMMA separated_nonempty_list(COMMA,PIDENT) [ RPAR ]
##
## The known suffix of the stack is as follows:
## PIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR RPAR IDENT EQ VBAR
##
## Ends in an error in state: 50.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR RPAR IDENT VBAR
##
## Ends in an error in state: 49.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR RPAR VBAR
##
## Ends in an error in state: 48.
##
## typedecl -> LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR . IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR loption(separated_nonempty_list(COMMA,PIDENT)) RPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE LPAR VBAR
##
## Ends in an error in state: 42.
##
## typedecl -> LPAR . loption(separated_nonempty_list(COMMA,PIDENT)) RPAR IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE PIDENT IDENT EQ VBAR
##
## Ends in an error in state: 4.
##
## typedecl -> PIDENT IDENT EQ . typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT IDENT EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE PIDENT IDENT VBAR
##
## Ends in an error in state: 3.
##
## typedecl -> PIDENT IDENT . EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT IDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE PIDENT VBAR
##
## Ends in an error in state: 2.
##
## typedecl -> PIDENT . IDENT EQ typeterm0 [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## PIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: TYPE VBAR
##
## Ends in an error in state: 1.
##
## decl -> TYPE . typedecl [ TYPE LETPMRS LET EOF ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

main: VBAR
##
## Ends in an error in state: 0.
##
## main' -> . main [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

